<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mz_CPP函数</title>
    <link href="/2024/10/12/mz-CPP%E5%87%BD%E6%95%B0/"/>
    <url>/2024/10/12/mz-CPP%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>挖个大坑，函数，这玩意讲的有点多，水不了，不多说了，进入正文  </p><h1 id="CPP函数"><a href="#CPP函数" class="headerlink" title="CPP函数"></a>CPP函数</h1><p><strong>首先来问一个问题：函数是什么？</strong>  </p><p>函数就是一个命名了的代码块，我们可以通过调用函数来执行相应的代码，函数可以有零个或者多个参数，而且只会产生一个结果  </p><p><strong>而为什么使用函数呢？</strong>  </p><p>假如没有函数这个东西，那么一大堆功能都必须写在一个地方，而且每次都得重新写麻烦就不说了，还不容易理解，而有了函数这个东西，这些常用的功能都可以通过创建别的函数来给他装起来，要用的时候再给他调用出来，方便，而且如果这个功能出错了可以直接通过修改函数来进行修复，以及增加新功能，让编写程序变得更加得方便了</p><p>接下来就直接进入正题吧</p><h3 id="主函数main"><a href="#主函数main" class="headerlink" title="主函数main"></a>主函数main</h3><p>还记得我们一开始就说的那个基本程序吗？<br>就是那个CPP基本程序，HELLOWORLD的那个<br>里面就有个函数叫做主函数 main<br>一般是这样写的</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：在CPP程序里必须要有一个主函数main才能运行(有且只有一个)</strong><br>接下来就让我们详细讲解一下，函数这个东西  </p><h3 id="函数基础讲解"><a href="#函数基础讲解" class="headerlink" title="函数基础讲解"></a>函数基础讲解</h3><p>要创建个函数需要提供函数原型和函数体<br>而函数体的组成是这样的：  </p><p><code>返回类型 函数名 (参数列表)&#123;代码块&#125;</code><br>这里如果不需要返回值就给返回类型那里使用void，如果是不需要参数就直接在把参数列表空着就好了  </p><p>接下来我们封装一串代码块进函数里  </p><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>我们就创建一个返回a+b的值的函数吧</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddData</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = x + y;<br>    cout &lt;&lt; a &lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样咱们就给这个名为AddData的函数装了个返回a+b的值的工具，调用也很简单，像是在main函数里调用其他函数的用法一样：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    AddData(<span class="hljs-number">12</span>,<span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>```  <br>这样就成功的调用函数AddData进行a+b的运算了  <br>如果之后我们要修改这个功能我们就可以直接在AddData函数里进行修改  <br>并且创建出来之后我们就可以不用在需要用这个功能的时候重新写了，直接把这个函数调用出来就可以了  <br>这样不仅减少了同一个功能需要重复输出，况且还让这个功能能够更方便的进行修改，更新了  <br><br>接下来我讲一下形参和实参。<br><span class="hljs-meta">### 形参，实参  </span><br>函数后面的那个括号内的参数叫做**形参(形式参数)**<br></code></pre></td></tr></table></figure><p>void AddData(int x,int y)<br>{<br>    int a &#x3D; x + y;<br>    cout &lt;&lt; a &lt;&lt;endl;<br>}</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs markdown">AddData后面的参数x，y就是形参  <br>关于形参，你可以这样理解：  <br>现在这些参数(x,y)，具体的值我不知道，我只知道他只是一个整型变量  <br><br>而在调用函数传进的参数就是<span class="hljs-strong">**实参(实际参数)**</span>，这个过程叫做<span class="hljs-strong">**传递参数**</span>，也就是传递具体的值给函数的形参，进行特地的操作，他就像一个公式一样，你必须给定一个实际的值，才能得到一个实际的结果，在传递参数的过程中需要注意一下几点：<br><span class="hljs-bullet">+</span> 传入的实参必须跟形参的类型一样  <br><span class="hljs-bullet">+</span> 传入的实参必须是按照顺序传递的<br><span class="hljs-bullet">+</span> 传入的实际参数的数量必须与形参的数量相同  <br><br>然后就是参数的定义，也需要记住以下几点：<br><span class="hljs-bullet">+</span> 每一个形参之间必须使用逗号隔开，并且注明类型<br><span class="hljs-bullet">+</span> 也可以不定义形参<br><span class="hljs-bullet">+</span> 形参可以是任何基本类型或者本身定义的类型，可以是指针，引用，值  <br><br><span class="hljs-section">### 函数的调用</span><br><span class="hljs-strong">**直接调用**</span>  <br>直接调用就是在代码中调用函数，比如说AddData()  <br><br><span class="hljs-strong">**嵌套调用**</span>  <br>嵌套调用指的是，举一个例子，在a函数中会调用b函数，而在b函数中又调用a函数  <br><br><span class="hljs-strong">**递归调用**</span>  <br>递归调用就是调用自己  <br><br><span class="hljs-section">### 函数的参数传递  </span><br>C++函数的传递，我觉得是一个~~很骚气的操作~~，他的值传递不像Java那么简单，如果不了解c++的传递类型，可能有一些方法的调用得到的结果往往不是我们预期的那样  <br>比如这里设计一个函数<br></code></pre></td></tr></table></figure><p>void Swaps(int a,int b)<br>{<br>    int temp &#x3D; a;<br>    a&#x3D;b;<br>    b&#x3D;temp;<br>}</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">你写了一个交换<span class="hljs-selector-tag">a</span>，<span class="hljs-selector-tag">b</span>两值的函数，于是在<span class="hljs-selector-tag">main</span>函数里测试这个函数，结果发现  <br>**&quot;我勒个豆啊，这咋没有交换呢？我这思路也没错啊？？？&quot;**    <br>这是什么原因呢？  <br>因为这是c++函数的传值差异，听我说了一下你或许就能大体明白一些了  <br><br>#### 值传递<br>每一个变量的定义都会在内存中对应一个地址，每一个地址是对应着特定的编号的，值即对这个对应内存里面储存的数据，将值作为形参传入数组，比如我上面的那个Swaps函数  <br>你以为Swap里面用到的<span class="hljs-selector-tag">a</span>，<span class="hljs-selector-tag">b</span>就是<span class="hljs-selector-tag">main</span>函数里面定义的<span class="hljs-selector-tag">a</span>，<span class="hljs-selector-tag">b</span>？  <br>但是实际却不是这样，可以对函数多一些修改，打印出他的内存地址  <br></code></pre></td></tr></table></figure><p>void Swaps(int a,int b)<br>{<br>    cout &lt;&lt;&amp;a&lt;&lt;endl;<br>    cout &lt;&lt;&amp;b&lt;&lt;endl;<br>    int temp &#x3D; a;<br>    a&#x3D;b;<br>    b&#x3D;temp;<br>}</p><p>int main()<br>{<br>    int a,b;<br>    cin &gt;&gt; a&gt;&gt;b;<br>    cout &lt;&lt; &amp;a&lt;&lt;endl<br>        &lt;&lt;&amp;b&lt;&lt;endl;<br>    cout &lt;&lt; a&lt;&lt;endl<br>        &lt;&lt;b&lt;&lt;endl;<br>    Swaps(a,b);<br>    cout &lt;&lt; a&lt;&lt;endl<br>        &lt;&lt;b&lt;&lt;endl;<br>    return 0;</p><p>}</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">然后这样运行之后你会发现，运行结果根本没有交换<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>的值，因为在Swaps里面的<span class="hljs-selector-tag">a</span>与<span class="hljs-selector-tag">b</span>和在<span class="hljs-selector-tag">main</span>函数里面输入的<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>地址都不一样，根本就不是同一个变量，所以这样交换数据的函数根本不是一个可以成功交换的函数，**他其实只是重新定义了两个int类型的变量，只是值与<span class="hljs-selector-tag">a</span>，<span class="hljs-selector-tag">b</span>相等**，所以值传递并不能达到改变变量的作用  <br>可以看到如果我们想弄不改变传入的变量的值时，我们就可以采用这种方法  <br><br>#### 指针传递 <br>指针传递传递的是指针变量，通过这个指针，我们可以修改这个指针指向的地址位置和变量数值，对于上面的那个Swaps函数，我们就可以使用指针传递的方式达到交换两个数据的效果  <br>来，上实例  <br></code></pre></td></tr></table></figure><p>void Swaps(int *a,int *b)<br>{<br>    cout &lt;&lt;&amp;a&lt;&lt;endl;<br>    cout &lt;&lt;&amp;b&lt;&lt;endl;<br>    int temp &#x3D; a;<br>    a&#x3D;b;<br>    b&#x3D;temp;<br>}</p><p>int main()<br>{<br>    int a,b;<br>    cin &gt;&gt; a&gt;&gt;b;<br>    int*x&#x3D;&amp;a,*y&#x3D;&amp;b<br>    cout &lt;&lt; &amp;a&lt;&lt;endl<br>        &lt;&lt;&amp;b&lt;&lt;endl;<br>    cout &lt;&lt; a&lt;&lt;endl<br>        &lt;&lt;b&lt;&lt;endl;<br>    Swaps(x,y);<br>    cout &lt;&lt; a&lt;&lt;endl<br>        &lt;&lt;b&lt;&lt;endl;<br>    return 0;</p><p>}</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">运行之后就可以发现这样达到了一个交换的效果，以指针的形式，但是可以看到传入的指针跟<span class="hljs-selector-tag">main</span>函数里的指针也是不一样的  <br>指针传递可以理解为另类的值传递，传递的指针参数也是一个变量类型，在这种Swaps函数里的修改其实是对**指针变量指向的内存地址里面的值进行修改**，就是<span class="hljs-selector-tag">main</span>函数里面变量<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>的地址里面的值进行修改，**也就可以理解为修改了<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>的值**  <br><br>#### 引用传递  <br>引用传递其实是跟地址传递具有相同的效果，唯一的区别是**引用变量一旦定义，里面指向的地址位置是不能修改的**，相当于前面加了个const  <br>来吧  <br></code></pre></td></tr></table></figure><p>void Swaps(int &amp;a,int &amp;b)<br>{<br>    cout &lt;&lt;&amp;a&lt;&lt;endl;<br>    cout &lt;&lt;&amp;b&lt;&lt;endl;<br>    int temp &#x3D; a;<br>    a&#x3D;b;<br>    b&#x3D;temp;<br>}</p><p>int main()<br>{<br>    int a,b;<br>    cin &gt;&gt; a&gt;&gt;b;<br>    cout &lt;&lt; &amp;a&lt;&lt;endl<br>        &lt;&lt;&amp;b&lt;&lt;endl;<br>    cout &lt;&lt; a&lt;&lt;endl<br>        &lt;&lt;b&lt;&lt;endl;<br>    Swaps(a,b);<br>    cout &lt;&lt; a&lt;&lt;endl<br>        &lt;&lt;b&lt;&lt;endl;<br>    return 0;</p><p>}</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css">这次的地址就相同了  <br>可以看到引用变量传入的值就是<span class="hljs-selector-tag">main</span>函数里的<span class="hljs-selector-tag">a</span>和<span class="hljs-selector-tag">b</span>，地址是一样的  <br><br>#### 数组传递  <br>一维数组  <br>数组的传递其实就是指针的传递，当然在C++的STL里面有个可以替代数组的更安全的类型array(这里先不考虑)  <br>对于C++里面的数组类型，其实就是一个指针类型，比如说定义一个数组int <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[]</span>，这里的<span class="hljs-selector-tag">a</span>就是指向<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[0]</span>的指针，要获取<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[1]</span>只需要<span class="hljs-selector-tag">a</span>++就可以了  <br>**这里的实例就不上了，就是上面的指针传递，只不过把指针变量换成了数组而已**  <br><br>二维数组  <br>二维数组其实也没啥，也就是按照一维数组的思想，但是人为的规定了一些限制，因为二维数组在内存中是顺序条状存储的，也就是从<span class="hljs-number">1</span>到n个连续的内存位置  <br>存储的是二维数组，人家计算机才不会管你的几行几列，他只知道只有顺序存储和链式存储，之所以有二维数组，是人为的规定了，比如<span class="hljs-number">1</span>到多少个内存位置是第一行···  <br>既然这样，~~那我也不装什么正人君子了~~  <br>我们可以用一个*<span class="hljs-selector-tag">p</span>来访问二维数组，于此同时也可以使用双指针(也就是行指针)来进行访问  <br>这个得上实例了<br>采用一维数组<br></code></pre></td></tr></table></figure><p>void a(int *p,int row,int lie)<br>{<br>    for(int i &#x3D; 0;i&lt;row;i++)<br>    {<br>        for(int j &#x3D; 0;j&lt;lie;j++)<br>        {<br>            cout &lt;&lt; *p;<br>            p++;<br>        }<br>        cout  &lt;&lt;endl;<br>    }<br>}</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">采用二维数组<br></code></pre></td></tr></table></figure><p>void a(int p[][3],int row,int lie)<br>{<br>    for(int i &#x3D; 0;i&lt;row;i++)<br>    {<br>        for(int j &#x3D; 0;j&lt;lie;j++)<br>        {<br>            cout &lt;&lt; p[i][j];<br>            p++;<br>        }<br>        cout  &lt;&lt;endl;<br>    }<br>}</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">采用行指针<br></code></pre></td></tr></table></figure><p>void a(int (*p)[3],int row,int lie)<br>{<br>    for(int i &#x3D; 0;i&lt;row;i++)<br>    {<br>        for(int j &#x3D; 0;j&lt;lie;j++)<br>        {<br>            cout &lt;&lt; ((p+i)+j);<br>            p++;<br>        }<br>        cout  &lt;&lt;endl;<br>    }<br>}</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">这三个方法都能打印出二维数组，但是他们的定义方式不同  <br>+ 一个是采用一维数组，也就是把二维数组当作一个长一点的一维数组，用指针往后自增来遍历二维数组中的每一个元素  <br>+ 另一个是采用索引的方法a[i][j]的形式，来访问二维数组中的每一个元素，但是形参的第二个[]里必须有一个常数，也就是你传入的二维数组的列数必须是跟形参一样的，否则无法传递<br>+ 第三个是以行指针的形式，他的访问方法如下  <br><br>|<span class="hljs-string">分类</span>|<span class="hljs-string">表示方法</span>|<span class="hljs-string">备注</span>|<br>|<span class="hljs-string">:---:</span>|<span class="hljs-string">:---:</span>|<span class="hljs-string">:---:</span>|<br>|<span class="hljs-string">行指针</span>|<span class="hljs-string">p+i,*p[i]</span>|<span class="hljs-string">下标为第i行的指针</span>|<br>|<span class="hljs-string">元素指针</span>|<span class="hljs-string">*(p+i)+j,p[i]+j</span>|<span class="hljs-string">第i行第j列的元素指针</span>|<br>|<span class="hljs-string">元素</span>|<span class="hljs-string">*(*(p+i)+j),(p[i]+j)</span>|<span class="hljs-string">第i行第j列的元素</span>|<br><br><span class="hljs-comment">#### 为参数默认值</span><br>在函数中，除了传递变量之外，还可以为设置的形参设置默认值，当一个参数具有默认值时，调用它的时候就可以不需要传入这个形式的参数  <br><br>怎么设置？  <br>直接来吧<br></code></pre></td></tr></table></figure><p>void a(int a &#x3D;10)<br>{<br>    cout &lt;&lt;a;<br>}</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">这样如果没有传递参数，那么他就会按照默认值进行处理，如果有传入参数，就按照传入的参数进行处理  <br><br>### 函数的重载  <br>函数的重载意思为：**相同的函数的函数名实现多种不同的功能**，一个相同的函数名他的参数数量和返回类型可以不同，用来实现他的功能  <br>接下来我就直接上实例吧  <br></code></pre></td></tr></table></figure><p>boll compare(int a,int b)<br>{<br>    return a&gt;b;<br>}<br>boll compare(double a,double b)<br>{<br>    return a&gt;b;<br>}</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">可以看到，函数名是相同的，他们都实现了一个比较的功能，为了简化这些代码，我们可以使用一下<span class="hljs-strong">**函数模板**</span>来写这些函数，函数模板我将会在后面介绍，这里来举一个栗子，一个物体是有面积的，但是对于不同的物体，传入的参数和求面积的方式是不一样的  <br></code></pre></td></tr></table></figure><p>void area(int r)<br>{<br>    cout&lt;&lt;”这个圆形的面积是：”&lt;&lt;3.14<em>r</em>r;<br>}<br>void area(int a,int b)<br>{<br>    cout &lt;&lt;”这个矩形的面积是：”&lt;&lt;a*b;<br>}</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">可以看到上面的函数定义中，一个area函数能有不同的求面积的方法，参数的数量和类型可以不同，这样就可以实现相同的函数名实现很多中方法  <br>接下来就讲一下函数模板  <br>### 函数模板<br>对于上面的compare函数，要实现不同的比较方法需要写很多代码，这样大大增加了代码的冗(rong)余度  <br>为了解决这个问题，c++里面是有一个函数模板编程方法的，也就是起始时我们不知道这个形参的具体类型是什么，而是在程序运行的时候将待定的变量代替这个模型，定义的格式为  <br></code></pre></td></tr></table></figure><p>template<typename T><br>bool compare(T a,T b)<br>{<br>    return a&gt;b;<br>}</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs r">我们并不知道<span class="hljs-built_in">T</span>的具体类型是什么样子，但是这样的话可以大大的减少代码的冗余度  <br>这个变量类型<span class="hljs-built_in">T</span>只有在实际的编译过程中根据用户输入的变量类型来替代  <br>但是<span class="hljs-built_in">T</span>不能是所有的变量类型，他也是有限制的，是根据代码来确定适配范围的，如果一个类型没有重载<span class="hljs-operator">&gt;</span>这个运算符，这种类型传入无法比较大小，这在程序运行的过程是会报错的  <br><br><br><span class="hljs-comment">### 内联函数  </span><br>在程序的运行中，一次函数的调用远非我们想象的只是执行几句语句那么简单，假设有这么一个函数  <br></code></pre></td></tr></table></figure><p>string&amp; ShortString(const string &amp;st1,const string &amp;st2)<br>{<br>    return st1.size()&gt;st2.size()?st2:st1;<br>}&#x2F;&#x2F;这个函数的意思就是返回两个字符串长度较小的字符串的引用类型</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">在ShortString函数执行的过程中，并不是简单的<span class="hljs-built_in">st1</span><span class="hljs-number">.</span>size()&gt;<span class="hljs-built_in">st2</span><span class="hljs-number">.</span>size()?<span class="hljs-built_in">st2</span>:<span class="hljs-built_in">st1</span><span class="hljs-comment">;  </span><br>在运行这句话之前，还有一系列的操作，比如说将函数入口拷贝到寄存器，并且在返回时恢复，或者需要拷贝实参，返回返回值···，需要经历一系列的操作之后，上面那一句话只是这一系列操作的一部分，那么对于这些十分简单的函数语句描述，可以用内联函数来实现  <br>内联函数能够避免函数调用的额外开销，将函数指定为内联函数，通常是在每个调用点的内联地址展开，而无需前面那么多步的操作  <br>定义内联函数十分简单，只需要在返回值前面加一个inline就可以了  <br>这里就将上面的函数改为内联函数<br></code></pre></td></tr></table></figure><p>inline string&amp; ShortString(const string &amp;st1,const string &amp;st2)<br>{<br>    return st1.size()&gt;st2.size()?st2:st1;<br>}</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean">这里需要注意：  <br>+ 内联函数只是一个声明，至于在编译的过程中编译器是否把这个函数当作内联函数，还得看编译器的想法，也就是有时我们可能觉得这个函数是内联函数，但是编译器在编译的过程中不这样认为  <br>+ 内联机制只适用于语句少，代码体简单的函数，如果函数比较复杂的话，<span class="hljs-keyword">inline</span>就没有作用了  <br><br>### 函数的指针  <br>函数指针也是函数调用中的一个方法，可以把函数想象成一个变量，那么对于函数也可以存在指针  <br>函数指针指向某种特定的类型，函数的类型由他的返回值和形参类型共同决定，与函数名无关  <br><br>**定义函数指针**  <br></code></pre></td></tr></table></figure><p>返回类型(*指针名)(形参列表);<br>例如前面定义的函数ShortString<br>string&amp; (*st)(const string &amp;st1,const string &amp;st2)</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**初始化函数指针**</span>  <br></code></pre></td></tr></table></figure><p>st &#x3D; ShortString;&#x2F;&#x2F;将st指向名为ShortString的函数<br>st &#x3D; &ShortString;&#x2F;&#x2F;和上面的等价，取地址符可选</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-strong">**使用函数指针**</span><br></code></pre></td></tr></table></figure><p>string s1 &#x3D; st(“abc”,”defs”);&#x2F;&#x2F;调用ShortString函数<br>string s2 &#x3D; (*st)(“abc”,”defs”);&#x2F;&#x2F;和上面的等价<br>string s3 &#x3D; ShortString(“abc”,”defs”);</p><pre><code class="hljs">定义的函数指针必须指向返回类型和形参类型和数量相同的函数，当函数指针为空时可以给他定义为NULL；  函数和函数指针可以作为函数中的形参  也可以用typedef和decltype用特定的名字代替函数指针和函数名  ----好了，终于写完了，晚安  记录时间：2024.10.13 1:13</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DT_JAVA基本程序</title>
    <link href="/2024/10/11/DT-JAVA%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F/"/>
    <url>/2024/10/11/DT-JAVA%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="JAVA的基本程序-Hello-World"><a href="#JAVA的基本程序-Hello-World" class="headerlink" title="JAVA的基本程序 Hello World"></a>JAVA的基本程序 Hello World</h2><p>代码如下：  </p><pre><code class="hljs">public class Hello World&#123;    public static void main(String[] args)&#123;        System.out.println(&quot;Hello Word&quot;);      //输出 Hello World    &#125;&#125;</code></pre><p>输出内容</p><p><code>Hollo World</code></p><p>第一次书写时应该注意类名的首字母应该大写，而属性，方法，对象变量以及所有标识符（如形式参数，实际参数，局部变量）的首字母应小写。   </p><h2 id="public-class-Hello-World"><a href="#public-class-Hello-World" class="headerlink" title="&#x2F;&#x2F;public class Hello World"></a>&#x2F;&#x2F;public class Hello World</h2><blockquote><p>public 关键字，允许在不同类不同包被访问  </p></blockquote><blockquote><p>class 关键字，用来声明新的JAVA类  </p></blockquote><blockquote><p>HelloWorld 标识符，代码中Hello World类的名字  </p></blockquote><h2 id="public-static-void-main-string-args"><a href="#public-static-void-main-string-args" class="headerlink" title="&#x2F;&#x2F;public static void main(string[] args)"></a>&#x2F;&#x2F;public static void main(string[] args)</h2><blockquote><p>static 关键字，修饰main方法，使其不依赖于Hello World类的对象  </p></blockquote><blockquote><p>main 标识符，代码中main方法函数的名字  </p></blockquote><blockquote><p>String[] 关键字，字符串数组，数据类型的一种  </p></blockquote><blockquote><p>args 标识符，代码中args字符串数组的名字  </p></blockquote><h2 id="System-out-println（“Hello-World”）"><a href="#System-out-println（“Hello-World”）" class="headerlink" title="/&#x2F;System.out.println（“Hello World”）"></a>/&#x2F;System.out.println（“Hello World”）</h2><blockquote><p>. 点号，访问号  </p></blockquote><blockquote><p>System 标识符，一个类的名字  </p></blockquote><blockquote><p>out 标识符，一个类的名字  </p></blockquote><blockquote><p>println 标识符，一个方法的名字，println()f方法可以将()内的字符串输出到标准输出流(屏幕)  </p></blockquote><blockquote><p>“Hello World” 字符串常量  </p></blockquote><blockquote><p>; 分号，一行代码的结束标志  </p></blockquote><blockquote><p>&#x2F;&#x2F; 注释符，单行注释  </p></blockquote><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mz_CPP判断语句</title>
    <link href="/2024/10/11/mz-CPP%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5/"/>
    <url>/2024/10/11/mz-CPP%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>今天想不出什么骚话，直接进入主题吧</p><h1 id="CPP的判断语句"><a href="#CPP的判断语句" class="headerlink" title="CPP的判断语句"></a>CPP的判断语句</h1><p>c++的判断语句很简单，和昨天写的那个循环一样，理解用法简单，但是真要用在程序里需要学习很久<br>首先来说一下最基本的  </p><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>if语句的构成：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(a==<span class="hljs-number">10</span>)</span></span><br>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;这个数等于10&quot;</span>&lt;&lt;endl；<br>&#125;<br></code></pre></td></tr></table></figure><p>答案为0（是）程序输出</p><blockquote><p>这个数等于10</p></blockquote><p>看懂了吗，就是：if(表达式){代码;}<br>当条件判断为0(是)的时候就运行代码块里面的内容，如果为1(否)便不运行</p><p><strong>那如果想做为否便输出另外一串代码怎么做呢？再添一个if？</strong><br>你能想到的，别人也能想到，接下来就让我们讲一讲if语句的另一种形式</p><h3 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if else语句"></a>if else语句</h3><p>他和if语句是一样的，那多的那个else是什么意思呢?<br>来，上实例  </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if(a<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-number">10</span>)<br>&#123;<br>    cout &lt;&lt;<span class="hljs-string">&quot;这个数等于10&quot;</span>&lt;&lt;endl<span class="hljs-comment">;</span><br>&#125;else<br>    &#123;<br>        cout &lt;&lt;<span class="hljs-string">&quot;这个数不等于10&quot;</span>&lt;&lt;endl<span class="hljs-comment">;</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>这样，如果条件判断为0(是)就输出if语句后面的代码块里的内容，跳过else<br>如果条件判断为1(否)就跳过if后面的代码块输出else的内容<br>我知道你又要说啥<br><strong>那是不是可以建立多个if else语句来做一个类似菜单的东西</strong><br>挺聪明的，但是真要这样做出来的不好理解，而且占内存，还不好写，但是官方提供了这么一个东西，你知道我要干嘛的  </p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>这玩意就是专门拿来做菜单这些的东西了，也能通过你自己定义的关键字来进行运行特定的代码块<br>来吧，上实例  </p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-keyword">switch</span> (a)&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:cout &lt;&lt; <span class="hljs-string">&quot;周一&quot;</span>&lt;&lt;<span class="hljs-literal">endl</span>; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:cout &lt;&lt; <span class="hljs-string">&quot;周二&quot;</span>&lt;&lt;<span class="hljs-literal">endl</span>; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:cout &lt;&lt; <span class="hljs-string">&quot;周三&quot;</span>&lt;&lt;<span class="hljs-literal">endl</span>; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:cout &lt;&lt; <span class="hljs-string">&quot;周四&quot;</span>&lt;&lt;<span class="hljs-literal">endl</span>; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:cout &lt;&lt; <span class="hljs-string">&quot;周五&quot;</span>&lt;&lt;<span class="hljs-literal">endl</span>; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:cout &lt;&lt; <span class="hljs-string">&quot;周六&quot;</span>&lt;&lt;<span class="hljs-literal">endl</span>; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:cout &lt;&lt; <span class="hljs-string">&quot;周日&quot;</span>&lt;&lt;<span class="hljs-literal">endl</span>; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:cout &lt;&lt;<span class="hljs-string">&quot;error&quot;</span>&lt;&lt;<span class="hljs-literal">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>switch后面的括号装的是表达式，表达式为0就开始运行这个switch语句<br>case后面放的是标签，如果输入的值为这个标签，便运行这个部分的代码，通常为整型，字符，字符串<br>然后就是每个部分最后的那个break,意为退出，如果不加这个，你输入完1点回车之后他会从那个地方一直运行到最后</p><p>学会了吗？这些都非常的简单，难的是运用，要多学，多写，多练  </p><hr><p>今天有点不舒服，说不出什么骚话，就大体的讲了一点点<br><del>终于水了一期啊 舒坦.jpg</del><br>记录时间：2024.10.11 17.14</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DT_Java特点</title>
    <link href="/2024/10/11/DT-Java%E7%89%B9%E7%82%B9/"/>
    <url>/2024/10/11/DT-Java%E7%89%B9%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="JAVA语言特点："><a href="#JAVA语言特点：" class="headerlink" title="JAVA语言特点："></a>JAVA语言特点：</h3><p>java的特点主要有：   </p><ul><li>跨平台性</li><li>面向对象</li><li>安全性</li><li>多线程</li><li>模块化</li><li>简单易学</li></ul><p>这里一 一列出来是因为以后找工作人家会问你<strong>JAVA 的特点</strong>是什么，这些或许会给你们带来一丁点的帮助  </p><p>接下来我们来说说各个特点  </p><p>1.跨平台性：  </p><blockquote><p>所谓的跨越平台性，是指软件可以不受计算机硬件和操作系统的约束而在任意计算级环境下正常运行。因为计算机的种类繁多，操作系统也各不相同，不同公司有自己不同的计算机环境偏好，而软件为了能在这些不同的环境里能够正常运行，就需要独立于这些平台。而在JAVA语言中，JAVA自带的虚拟机很好的实现了跨平台性。JAVA源程序代码经过编译后生成的二进制的字节码是与平台没有关系的，但是可被JAVA虚拟机识别的一种机器码的指令。JAVA虚拟机提供了一个字节码到底层硬件平台及操作系统的屏障，使得JAVA语言具有跨平台性   </p></blockquote><p>2.面向对象：</p><blockquote><p>JAVA呢是一种面向对象的一种语言，它是对对象中的类，对象，继承，封装，多态，接口，包等都有很好的支持。为了简便，JAVA只支持类之间的单继承。使用JAVA来开发程序，需要采用面向对象的思想来编写代码。  </p></blockquote><p>3.安全性：</p><blockquote><p>安全性又分为四个层面，即语言级安全性，编译时的安全性，运行时的安全性，可执行代码的安全性。然后语言级安全性是指JAVA的数据结构是完整的对像，然而这些封装过的数据类型具有安全性。编译时一定要进行JAVA语言和语义的检查，保证每个变量对应一个相应的值，编译后生成JAVA类。  </p></blockquote><p>4.多线程：</p><blockquote><p>多线程在操作系统中已得到了最成功的应用。多线程是指允许一个应用程序同时存在两个或两个以上的线程，用于事务并发和多任务处理。JAVA除了内置的多线程技术之外，还定义了一些类。方法来建立和管理用户定义的多线程  </p></blockquote><p>5.模块化：</p><blockquote><p>基于JAVA的模块化远程监测分析系统设计与实现  </p></blockquote><p>6.简单易学：</p><blockquote><p>JAVA源代码书写不拘泥于特定的环境，可以用记事本，文本编译器等编辑软件来实现，然后将源文件进行编译，编译通过后可直接运行，通过调试则可得到想要的结果。  </p></blockquote><p>好了，特点也就写到这里，如果有什么的地方不足，待我之后再补充<br>为了写这个 我都做好了通宵的准备<br>哈哈哈哈……..感谢你的观看 下次见！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DT_个人介绍</title>
    <link href="/2024/10/10/DT-%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/10/10/DT-%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h1><p>鄙人不才 因同伙想拉我下水 让我接触到了Java 我记得最清楚他说的一句话“既然接触了这玩意就得做好不吃饭的准备 而他已经做好了买炒粉的打算。”  </p><p>没办法 受不了好奇心的诱惑 学上了java 走上了程序这条路  </p><p>第一次看到这玩意儿 满心好奇 但说实在的 我对这个挺感兴趣的 然后就疯狂看书 上课认真听了自己最为偏科的数学 更为神奇的是 我居然听懂了  </p><p>学到前端我开始头疼了 网上看不完的课 晚上练习无数遍 记性超负荷共工作 我生怕把我室友电脑给敲坏了 哎………   </p><p>加油吧！后面的路还很长<br>拉着我的室友一起躺尸</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mz_CPP循环</title>
    <link href="/2024/10/10/mz_CPP%E5%BE%AA%E7%8E%AF/"/>
    <url>/2024/10/10/mz_CPP%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<p>今天来讲一讲c++的循环</p><h1 id="CPP循环"><a href="#CPP循环" class="headerlink" title="CPP循环"></a>CPP循环</h1><p>循环的运作方式就是<strong>当满足条件时进入循环，当循环不满足的时候跳出循环</strong><br>先来说一下while循环  </p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>while语句的一般条件是：while（表达式）{循环体}  </p><h5 id="while循环的用法"><a href="#while循环的用法" class="headerlink" title="while循环的用法"></a>while循环的用法</h5><p>1.while的格式  </p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">while</span><span class="hljs-comment">(循环条件)</span><br>&#123;<br>    循环体;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.while循环的用法<br>来，上实例：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">#include &lt;iostream&gt;<br>using namespace std;<br>int main()<br>&#123;<br>    int i = 0;<br>    while(i&lt;10)<br>    &#123;<br>        cout &lt;&lt; &quot;我吃了第&quot; &lt;&lt; i &lt;&lt;&quot;颗糖&quot;&lt;&lt;endl;<br>        i++<br>    &#125;<br>    return 0;<br>&#125;<br>```  <br>这样输出的结果就是：<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">我吃了第<span class="hljs-number">1</span>颗糖  </span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">我吃了第<span class="hljs-number">2</span>颗糖  </span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">我吃了第<span class="hljs-number">3</span>颗糖  </span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">我吃了第<span class="hljs-number">4</span>颗糖  </span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">我吃了第<span class="hljs-number">5</span>颗糖  </span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">我吃了第<span class="hljs-number">6</span>颗糖  </span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">我吃了第<span class="hljs-number">7</span>颗糖  </span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">我吃了第<span class="hljs-number">8</span>颗糖  </span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">我吃了第<span class="hljs-number">9</span>颗糖  </span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">我吃了第<span class="hljs-number">10</span>颗糖</span><br><br>为什么会这样呢？  <br>我跟你解释一下你就知道了  <br>i=0 开始循环  <br>第一次加1，使i=1，然后进行循环体的运行  <br>第二次加1，使i=2...<br>直到第十次  <br>i已经不小于10了，所以退出循环  <br>循环和if语句常用于算法（if语句明天再讲）  <br>### for是什么  <br>for循环的原理和while差不多，只不过就是语句长的不一样罢了  <br>for (单次表达式;条件表达式;末尾循环体)&#123;中间循环体;&#125;  <br><br>##### for语句的用法  <br>1.for语句的结构  <br></code></pre></td></tr></table></figure><p>for(单次表达式;条件表达式;末尾循环体)<br>{<br>    中间循环体;<br>} </p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">2.</span>for的用法  <br>还记得上面我写的那个糖程序吗<span class="hljs-comment">(记不得了我锤你)</span>  <br>来，我给他改成for循环  <br></code></pre></td></tr></table></figure><p>#include <iostream><br>using namespace std;<br>int main()<br>{<br>    for(int i &#x3D; 0;i &lt;10;i++)<br>    {<br>        cout &lt;&lt;”我吃了”&lt;&lt;i&lt;&lt;”颗糖”&lt;&lt;endl;<br>    }<br>    return 0;<br>}</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">这里要注意一点**<span class="hljs-keyword">for</span>会执行完i==<span class="hljs-number">10</span>的这段代码，但<span class="hljs-keyword">while</span>不会，<span class="hljs-keyword">while</span>发现i<span class="hljs-string">\==10，不&lt;10会马上退出**</span>  <br>下面解释一下<span class="hljs-keyword">for</span>的格式  <br>首先先定义赋值变量（如果不需要赋值就可以不输入）然后使用分号隔开，执行循环体的要求，再次用分号隔开，循环执行完一次之后变量的变化（也是一样的如果不需要可以不输入）  <br><br>常用的就这些，再说一下按顺序遍历数组吧  <br><span class="hljs-comment">### 小tip  </span><br></code></pre></td></tr></table></figure><p>#include <iostream><br>using namespace std;<br>int main()<br>{<br>    int MAX&#x3D;5;<br>    int a[MAX]&#x3D;{10,20,30,40,50};<br>    for(int i &#x3D; 0;i&lt;MAX;i++)<br>    {<br>        cout &lt;&lt; a[i] &lt;&lt;endl;<br>    }<br>    return 0;<br>}</p><pre><code class="hljs">这样编译后它就能一个一个的输出数组里的值了---~~我变的好快~~  这次的很简单，一会就写完了，学会怎么用很简单，但是要如何运用在程序里，就有点难，好了，明天写if语句  记录时间：2024.10.10  16.58  </code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mz_CPP指针</title>
    <link href="/2024/10/09/mz_CPP%E6%8C%87%E9%92%88/"/>
    <url>/2024/10/09/mz_CPP%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<p>今天就讲一下CPP里的指针  </p><h2 id="CPP指针"><a href="#CPP指针" class="headerlink" title="CPP指针"></a>CPP指针</h2><p>关于指针，这玩意是从c里面带来的，应用在程序里可以简化一些CPP编程任务的执行，还有些任务就像是动态内存分配，没有指针是没办法执行的，所以如果想要更精通CPP，学习指针是很有必要的<br><del>学习指针是一件非常有趣的事哦</del>    </p><h4 id="内存地址相关"><a href="#内存地址相关" class="headerlink" title="内存地址相关"></a>内存地址相关</h4><p>在学习CPP的时候，你应该会知道：每个变量都有一个内存位置，每个内存位置都可以用连字号（&amp;）来访问地址，它表示了在内存中的一个地址，如何使用呢？看下面  </p><blockquote><p>int a &#x3D; 12;<br>cout &lt;&lt; &a;  </p></blockquote><p>当上面这串代码执行之后他就会输出变量a的所在地址  </p><p>说了这些，你应该能知道什么是内存地址以及怎么访问他了，那接下来就正式的进入指针  </p><h4 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h4><p>指针就是个变量，他的值为指向另一个变量的地址，也就是内存位置的直接地址<br>指针就像别的变量和常量一样，你必须在使用指针存储别的变量地址之前对他进行声明<br>他一般是这样声明的：<br><code>type *var-name</code><br>type在这里是指针的基类型，他必须是一个有效的c++数据类型，var-name是指针变量名<br>用来声明指针的运算符 * 和乘法的那个星号是一样的，但是在这里，星号是用来指定一个变量是指针的<br>下面的这些就是有效的声明方式：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int* a<span class="hljs-comment">;</span><br>double * a<span class="hljs-comment">;</span><br>char *a<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这些都是有效的声明方式<br>所有指针的值的实际数据类型，不管是整值还是别的什么数据类型，都是一样的，都是一个代表内存地址长的十六进制数<br>不同的数据类型的指针之间唯一的不同就是指针所指向的变量或者是常量的数据类型不同而已  </p><h4 id="在CPP中使用指针"><a href="#在CPP中使用指针" class="headerlink" title="在CPP中使用指针"></a>在CPP中使用指针</h4><p>使用指针的时候会频繁进行这些操作：定义一个指针变量，把变量地址赋给指针，访问指针变量中可用地址的值<br>这些都是通过一元运算符 * 来返回位于操作数指定地址的变量的值<br>接下来我就往这里丢一个示例  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;<span class="hljs-comment">//声明整型变量</span><br><span class="hljs-type">int</span>* pt = &amp;a;<span class="hljs-comment">//声明指针变量并将指向a</span><br><br>cout &lt;&lt; a &lt;&lt; endl;<span class="hljs-comment">//输出这个变量</span><br><br>cout &lt;&lt; pt &lt;&lt; endl;<span class="hljs-comment">//输出指针变量中储存的地址</span><br><br>cout &lt;&lt; *pt &lt;&lt; endl;<span class="hljs-comment">//输出指针中地址的值</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="CPP指针详解"><a href="#CPP指针详解" class="headerlink" title="CPP指针详解"></a>CPP指针详解</h4><p>在c++中，有很多相关的概念，这些概念虽然很<del>简单</del>，但是都很重要<br>下面的表格内我列出了一些必须清楚的指针相关的重要概念：</p><table><thead><tr><th align="center">概念</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">C++ Null指针</td><td align="center">c++支持空指针，NULL指针是一个定义在标准库中的值为零的常量</td></tr><tr><td align="center">C++指针的算术运算</td><td align="center">可以对指针进行四种算数运算：++，–，+，-</td></tr><tr><td align="center">C++指针 vs 数组</td><td align="center">指针和数组之间有密切的关系</td></tr><tr><td align="center">C++指针数组</td><td align="center">可以定义用来储存指针的数组</td></tr><tr><td align="center">C++指向指针的指针</td><td align="center">c++允许指向指针的指针</td></tr><tr><td align="center">C++传递指针给函数</td><td align="center">通过引用或地址传递参数，使传递的参数在调用函数中被改变</td></tr><tr><td align="center">C++从函数返回指针</td><td align="center">C++允许函数返回指针到局部变量，静态变量和动态内存分配</td></tr></tbody></table><h5 id="C-Null指针"><a href="#C-Null指针" class="headerlink" title="C++ Null指针"></a>C++ Null指针</h5><p>在变量声明的时候，如果没有明确的地址可以赋值，为指针变量赋值一个NULL值是一个良好的编程习惯，这样的指针被称为空指针  </p><p>NULL指针是一个定义在标准库中值为零的常量<br>就像这样声明<br><code>int *pt = NULL;</code><br>这样声明的指针他输出的结果就是无也就是0  </p><p>在大多数的操作系统上，程序不允许访问地址为0的地址，因为这个内存是操作系统保留的<br>但是内存地址0有特别重要的意义，它表明该指针不指向一个可访问的内存位置<br>但按照惯例，如果指针包含空值（零值），就假定它不指向任何东西  </p><p>如果所有未使用的指针都被赋予空值，同时避免使用空指针，就可以防止误用一个未初始化的指针  </p><h5 id="C-指针的算术运算"><a href="#C-指针的算术运算" class="headerlink" title="C++指针的算术运算"></a>C++指针的算术运算</h5><p>指针是一个用数值表示的地址<br>因此，可以对指针进行四种算术运算：++，–，+，-  </p><p>假设ptr是一个指向地址1000的整型指针，是一个32位的整数，试试对他进行下面的算术运算：<br><code>ptr++</code><br>在执行完上面的运算之后，ptr将指向位置1004，因为ptr每增加一次，他都将指向下一个整数的位置，也就是当前位置往后移4个字节<br>这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置<br>如果ptr指向一个地址为1000的字符，上面的运算会导致指针指向1001，因为下一个字符的位置是1001  </p><h6 id="递增一个指针"><a href="#递增一个指针" class="headerlink" title="递增一个指针"></a>递增一个指针</h6><p>我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，但数组不行，因为数组是一个常量指针<br>下面我用了一个小程序来顺序访问数组中的每一个内容： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">3</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a[MAX] = &#123; <span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span> &#125;;<br><span class="hljs-type">int</span>* pt = a;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX; i++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;a[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;] =&quot;</span> &lt;&lt; pt &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;他的值为：&quot;</span> &lt;&lt; *pt &lt;&lt; endl;<br><br>pt++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码执行之后它会产生以下结果：  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[0]</span> =<span class="hljs-number">00000094277</span>EF5E8<br>他的值为：<span class="hljs-number">10</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[1]</span> =<span class="hljs-number">00000094277</span>EF5EC<br>他的值为：<span class="hljs-number">20</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[2]</span> =<span class="hljs-number">00000094277</span>EF5F0<br>他的值为：<span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p>与之类似，递减也是一样的方法  </p><h5 id="C-指针vs数组"><a href="#C-指针vs数组" class="headerlink" title="C++ 指针vs数组"></a>C++ 指针vs数组</h5><p>指针和数组是密切相关的<br>事实上，指针和数组在很多情况下是可以互换的<br>例如，一个指针指向数组开头的指针，就可以通过使用指针的算术运算或数组索引来访问数组<br>我就不放示例就是上面的那个“递增一个指针”  </p><p>如果把指针运算符 * 应用到a上是完全可以接受的，但修改a的值是非法的<br>这是因为a是一个指向数组开头的常量，不能作为左值  </p><p>由于一个数组名对应一个指针常量，只要不改变数组的值，仍然可以用指针形式的表达式<br>例如，下面是一个有效的语句，把a[2]赋值为500<br><code>*(a+2) = 500;</code></p><h5 id="C-指向指针的指针（多级间接寻址）"><a href="#C-指向指针的指针（多级间接寻址）" class="headerlink" title="C++ 指向指针的指针（多级间接寻址）"></a>C++ 指向指针的指针（多级间接寻址）</h5><p>指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链<br>通常，一个指针包含一个变量的地址<br>当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针包含实际值的位置  </p><p>一个指向指针的指针变量必须如下声明（就是在变量名前面加两个星号）<br><code>int **a;</code><br>当一个目标值被一个间接指向另一个指针时，访问这个值需要使用两个星号运算符，就像下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span>* pt;<br><span class="hljs-type">int</span>** ppt;<br><br>a = <span class="hljs-number">10</span>;<br><br>pt = &amp;a;<span class="hljs-comment">//获取变量a的地址</span><br><br>ppt = &amp;pt;<span class="hljs-comment">//获取pt的地址</span><br><br>cout &lt;&lt; **ppt;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就成功的使用了多级间接寻址  </p><h5 id="C-传递指针给函数"><a href="#C-传递指针给函数" class="headerlink" title="C++ 传递指针给函数"></a>C++ 传递指针给函数</h5><p>c++允许传递指针给函数，只需要简单的声明函数参数为指针类型就好了<br>下面的示例中我就使用了传递指针给函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">abb</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>* a)</span></span><br><span class="hljs-function"></span>&#123;<br>*a = <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);<span class="hljs-comment">//获取当前秒数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ba;<br><br><span class="hljs-built_in">abb</span>(&amp;ba);<br>cout &lt;&lt; ba;<span class="hljs-comment">//输出实例值</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，他会产生下列的结果</p><blockquote><p>1728481935  </p></blockquote><p><strong>既然它能接受指针作为参数，那它可不可以接受数组呢？</strong><br>答案是可以的，请看下面示例  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">5</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">abb</span><span class="hljs-params">(<span class="hljs-type">int</span>* a)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX; i++)<br>&#123;<br>cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a[MAX] = &#123; <span class="hljs-number">15</span>,<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">56</span>,<span class="hljs-number">59</span> &#125;;<br><span class="hljs-built_in">abb</span>(a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样编译出来的结果就是：</p><blockquote><p>15 12 23 56 59  </p></blockquote><p>终于到了最后一个东西了  </p><h5 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h5><p>new，是c++提供的用于动态申请储存空间的运算符  </p><h6 id="new的使用"><a href="#new的使用" class="headerlink" title="new的使用"></a>new的使用</h6><p>这里就直接上实例吧  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">int</span> *<span class="hljs-keyword">pt</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>这样就使用new声明出了一个变量<br><strong>那么可不可以用new声明数组呢？</strong><br>可以啊，怎么不可以，和上面类似，来，上实例  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span>*p=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>接下来就要说一个很重要的点，使用delete对他进行释放</p><h6 id="delete运算符的使用。"><a href="#delete运算符的使用。" class="headerlink" title="delete运算符的使用。"></a>delete运算符的使用。</h6><p>new运算符通常搭配detlete元素来使用，new用来动态申请存储空间，delete用于释放new申请的空间。<br>语法格式如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">delete p<span class="hljs-comment">;</span><br>delete[] arr<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>如果你使用完new然后你不使用delete给他释放会发生什么呢？<br>很简单的，他直接就nm的内存溢出（完啦，都完啦）<br>所以说<strong>用完new之后一定要使用delete给他进行释放</strong></p><hr><p>tips：我嘞个豆，写了我将近三百行，下次写循环和判断语句<br>记录时间：2024.10.9 22.29</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mz_CPP的运算符</title>
    <link href="/2024/10/08/mz_CPP%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2024/10/08/mz_CPP%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p><del>我就不信今天还不能水一期了</del>  </p><h2 id="CPP运算符"><a href="#CPP运算符" class="headerlink" title="CPP运算符"></a>CPP运算符</h2><p>首先就是最简单的几种</p><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><table><thead><tr><th align="center">运算符</th><th align="center">说明</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加法运算符 将a和b相加</td><td align="center">a+b</td></tr><tr><td align="center">-</td><td align="center">减法运算符 将a和b相减</td><td align="center">a-b</td></tr><tr><td align="center">*</td><td align="center">乘法运算符 将a和b相乘</td><td align="center">a*b</td></tr><tr><td align="center">&#x2F;</td><td align="center">除法运算符 将a和b相除</td><td align="center">a&#x2F;b</td></tr><tr><td align="center">%</td><td align="center">取模运算符（取余数）取a除b的余数</td><td align="center">a%b</td></tr><tr><td align="center">++</td><td align="center">自增运算符 将a加1（常用于循环）</td><td align="center">a++</td></tr><tr><td align="center">–</td><td align="center">自减运算符 将a减1（也是常用于循环）</td><td align="center">a–</td></tr></tbody></table><p>这些就是最基本的运算符：算数运算符<br>怕待会忘记了就在这里说一下赋值运算符：&#x3D;<br>赋值运算符用于给变量（对象）赋值  </p><p>接下来要将另外一类  </p><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>设变量a为10，变量b为20  </p><table><thead><tr><th align="center">运算符</th><th align="center">说明</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">&#x3D;&#x3D;</td><td align="center">检查两个操作数的值是否相等，如果相等则为真</td><td align="center">(a&#x3D;&#x3D;b)不为真</td></tr><tr><td align="center">!&#x3D;</td><td align="center">检查两个数是否相等，如果不相等就为真</td><td align="center">(a!&#x3D;b)为真</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">检查a是否大于等于b，如果是就为真</td><td align="center">(a&gt;&#x3D;b)不为真</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">检查a是否小于等于b，如果是就为真</td><td align="center">(a&lt;&#x3D;b)为真</td></tr><tr><td align="center">&gt;</td><td align="center">检查a是否大于b，如果是就为真</td><td align="center">(a&gt;b)不为真</td></tr><tr><td align="center">&lt;</td><td align="center">检查a是否小于b，如果是就为真</td><td align="center">(a&lt;b)为真</td></tr></tbody></table><p>说到这里，有一点要注意 <strong>&#x3D;和&#x3D;&#x3D;不能混用</strong>一个是赋值运算符，一个是等于运算符，（a&#x3D;b）这样写出来程序会给出报错  </p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>这里设a为1，b为2<br>这里就说最常用的三个    </p><table><thead><tr><th align="center">运算符</th><th align="center">说明</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">&amp;&amp;</td><td align="center">逻辑与，若两个关系式都为0(真)，则条件为真</td><td align="center">(a&lt;0&amp;&amp;b&gt;0)为假</td></tr><tr><td align="center">||</td><td align="center">逻辑或，若两个关系式有一个为0(真)，则条件为真</td><td align="center">(a&lt;0||b&gt;0)为真</td></tr><tr><td align="center">!</td><td align="center">逻辑否，这个将两个关系式的结果逆转，原本为真的加上这个会变为否</td><td align="center">!(a&lt;0&amp;&amp;b&gt;0)为真</td></tr></tbody></table><blockquote><p>说起来这里要注意一点，&amp;&amp;和||有短路机制，也就是：<br>&amp;&amp;：如果表达式1为否，那他就会短路，不会继续判断第二个表达式<br>||：这个也一样，如果表达式1为真，他就会短路，不会继续判断第二个  </p></blockquote><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>假设变量a为60，变量b为13<br>用二进制表示为：00111100，0001101</p><table><thead><tr><th align="center">运算符</th><th align="center">说明</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">按位与，如果同时存在与两个操作数中，二进制AND运算符复制一位到结果中</td><td align="center">(a&amp;b)将得到12，也就是00001100</td></tr><tr><td align="center">|</td><td align="center">按位或，如果存在于任意操作中，二进制OR运算符复制一位到结果中。</td><td align="center">（a\b）将得到61，即为0011 1101</td></tr><tr><td align="center">^</td><td align="center">如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制或运算符复制一位到结果中</td><td align="center">(a^b)将得到49，也就是00110001</td></tr><tr><td align="center">~</td><td align="center">二进制补码运算符是一元运算符，具有”翻转”位的作用</td><td align="center">(~a)将得到-61,也就是11000011，二的补码格式，带符号的二进制数</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">二进制左移运算符，左操作数的值向左移动右操作数指定的位数</td><td align="center">a&lt;&lt;2得到240，也就是11110000</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">二进制右移运算符，左操作数的值向右移动右操作数指定的位数</td><td align="center">a&gt;&gt;2得到15，也就是00001111</td></tr></tbody></table><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>这个就比较简单了  </p><table><thead><tr><th align="center">运算符</th><th align="center">说明</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">&#x3D;</td><td align="center">最简单的一个，他就叫赋值运算符，将右边的操作数赋给左操作数</td><td align="center">a&#x3D;10</td></tr><tr><td align="center">+&#x3D;</td><td align="center">加赋值运算符，将右操作数加上左操作数并赋值给左操作数</td><td align="center">a+&#x3D;10</td></tr><tr><td align="center">-&#x3D;</td><td align="center">减赋值运算符，将右操作数减去左操作数并赋值给左操作数</td><td align="center">a-&#x3D;10</td></tr><tr><td align="center">*&#x3D;</td><td align="center">乘赋值运算符，将右操作数乘以左操作数并赋值给左操作数</td><td align="center">a*&#x3D;10</td></tr><tr><td align="center">%&#x3D;</td><td align="center">取模赋值运算符，取两边操作数的模并赋值给左操作数</td><td align="center">a%&#x3D;10</td></tr><tr><td align="center">&lt;&lt;&#x3D;</td><td align="center">左移赋值运算符</td><td align="center">a&lt;&lt;&#x3D;2等同于a&#x3D;a&lt;&lt;2</td></tr><tr><td align="center">&gt;&gt;&#x3D;</td><td align="center">右移赋值运算符</td><td align="center">a&gt;&gt;&#x3D;2等同于a&#x3D;a&gt;&gt;2</td></tr><tr><td align="center">&amp;&#x3D;</td><td align="center">换位与赋值运算符</td><td align="center">a&amp;&#x3D;2等同于a&#x3D;a&amp;2</td></tr><tr><td align="center">^&#x3D;</td><td align="center">换位异赋值运算符</td><td align="center">a^&#x3D;2等同于a&#x3D;a^2</td></tr><tr><td align="center">|</td><td align="center">换位或赋值运算符</td><td align="center">a|&#x3D;2等同于a&#x3D;a|2</td></tr></tbody></table><h4 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h4><p>这个就是些杂项的了  </p><table><thead><tr><th align="center">运算符</th><th align="center">说明</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">sizeof</td><td align="center">sizeof运算符将取变量的大小</td><td align="center">sizeof(a)将返回4，其中a为整数</td></tr><tr><td align="center">,</td><td align="center">逗号运算符会顺序执行一系列的运算，整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值</td><td align="center">这个我想不出怎么表达，自己试试吧</td></tr><tr><td align="center">.和-&gt;</td><td align="center">成员运算符，这俩主要用于类引用类，结构体和共用体的成员</td><td align="center">这个你也自己试试口巴</td></tr><tr><td align="center">Cast</td><td align="center">强制转换运算符(这个Cast只是他的名字)，强制将当前类型的值转换为另外一种类型</td><td align="center">int（2.26）</td></tr><tr><td align="center">&amp;</td><td align="center">指针运算符&amp;，这玩意将返回选中变量实际的地址</td><td align="center">&amp;a 返回a的实际地址</td></tr><tr><td align="center">*</td><td align="center">指针运算符*</td><td align="center">*a，将指向a</td></tr></tbody></table><p>说到这里，应该说一下 <strong>运算符优先级</strong>的但是吧。。。你直接拿括号括起来解决一切问题：&gt;  </p><h4 id="一目-二目-三目运算符"><a href="#一目-二目-三目运算符" class="headerlink" title="一目 二目 三目运算符"></a>一目 二目 三目运算符</h4><p>这个很好理解<br>一目运算符就是只需要一个操作数就可以的运算符，例如：自增运算符，自减运算符<br>二目运算符就是需要两个操作数才可以的运算符，例如：赋值运算符，加法运算符<br>三目运算符就是需要三个操作数才可以的运算符，例如： ? :</p><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p><strong>什么是运算符的重载？</strong><br>就是运算符与类的结合，产生出新的定义<br><strong>为什么要使用运算符的重载？</strong><br>为了实现类的多态性  </p><hr><p>艾玛这次水了一百多行，<del>真好啊</del>，明天见咯~<br>拜拜~~<br>记录时间：2024.10.8 22.14</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mz_CPP变量</title>
    <link href="/2024/10/07/mz_CPP%E5%8F%98%E9%87%8F/"/>
    <url>/2024/10/07/mz_CPP%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>关于cpp的变量，和其他的都一样，下面就简单的<del>水一下帖子</del>讲解一下  </p><h2 id="1-CPP变量"><a href="#1-CPP变量" class="headerlink" title="1. CPP变量"></a>1. CPP变量</h2><p>变量的概念简单来说就是一个具有名称，可以供程序员操作的一个储存空间<br>cpp是静态型编译语言，所以在定义变量的时候必须明确指明变量的数据类型  </p><h4 id="1-1-变量的定义"><a href="#1-1-变量的定义" class="headerlink" title="1.1 变量的定义"></a>1.1 变量的定义</h4><p>变量定义的基本格式很简单，就像下面的示例一样<br><code>int a = 60；</code><br>也就是：  </p><blockquote><p>变量类型 变量名 &#x3D; 值；  </p></blockquote><p>如果要声明多个变量，就将给他变为：</p><blockquote><p> 变量类型 变量名1 &#x3D; 值,变量名2 &#x3D; 值；  </p></blockquote><p>用逗号隔开就ok了</p><p>说起来要注意一个事：<br><strong>在cpp里有对象和变量两种说法，很多人分不清他俩的区别，对象是指的是一块能存放数据并且具有某种类型的储存空间。单单从定义上来说，他俩其实都是同一个东西只是有人习惯把与类有关的称为对象，怎么称呼完全取决于自己，就像方法和函数的区分</strong></p><h4 id="1-2-初始值"><a href="#1-2-初始值" class="headerlink" title="1.2 初始值"></a>1.2 初始值</h4><p>当一个变量在声明的时候就给他赋值，这被称为这个变量被初始化了</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> a = <span class="hljs-number">60</span><br><span class="hljs-comment">//这个值被初始化了</span><br></code></pre></td></tr></table></figure><p>这里初始化和赋值是两个概念：<br>初始化是在变量（对象）创建的时候就给他赋值，给他一个初始值<br>赋值是把变量（对象）当前的值擦除，用新的值代替<br>虽然他俩是两个不同的概念，但是其实不太会影响编写程序  </p><p>初始化有很多种方法：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int a <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-comment">;</span><br>int a <span class="hljs-operator">=</span>&#123;<span class="hljs-number">10</span>&#125;<span class="hljs-comment">;</span><br>int a&#123;<span class="hljs-number">10</span>&#125;<span class="hljs-comment">;</span><br>int a(<span class="hljs-number">10</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这个怎么用就看你的习惯了  </p><p>而创建的时候就给他初始化，和先声明，之后再给他赋值，我更建议先给他初始化<br>如果你对没有进行初始化的变量进行输出他的值的时候你会发现<br><strong>“哎？我靠，他输出了个啥”</strong><br><strong>“哎？他怎么又双叒叕报错了？？？”</strong>  </p><p>这是为什么呢？很简单，这是由于cpp中有一个默认初始化机制，在任何的函数体内，变量如果不进行人为的初始化，变量就不会初始化，但是定义在任何函数体之外的变量都会被初始化为零  </p><blockquote><p><strong>注意</strong><br>虽然cpp有默认初始化机制，但还是建议对变量进行初始化，这样才能保证程序的安全，也能养成良好的编程习惯  </p></blockquote><h4 id="1-3-标识符"><a href="#1-3-标识符" class="headerlink" title="1.3 标识符"></a>1.3 标识符</h4><p>cpp的标识符只能由字母，数字，下划线构成，但是数字不能拿来开头，只能用字母和下划线开头，例如：<br><code>int 1a = 10</code><br>这样写他会报错<br>关于标识符，我们在定义的时候，应该遵从相应的规则，这样才能使代码显得更加规整</p><blockquote><p>定义标识符的规则<br>1， 尽量使用英语单词或者缩写，要见名知意思<br>2，变量一般用小写开头，类名用大写字母开头<br>3，对于组合的单词，中间用下划线隔开  </p></blockquote><h4 id="1-4-名字的作用域"><a href="#1-4-名字的作用域" class="headerlink" title="1.4 名字的作用域"></a>1.4 名字的作用域</h4><p>作用域指的是变量或者对象，函数等具有功能性的一个范围，通常是以{}为界限。关于作用域这个概念，并没有什么难点，只需知道，只有在与之对应的作用域里，变量（对象），函数等实体才具有功能。</p><p>接下来，我举个栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a=<span class="hljs-number">40</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">10</span>；<span class="hljs-comment">//这里的i只能在这里使用，超出了就不能使用了</span><br>        cout &lt;&lt; i;<br>    &#125;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">20</span>;<span class="hljs-comment">//这里能重新定义，因为上面的那个已经失效了</span><br>    cout &lt;&lt; i;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<span class="hljs-comment">//报错，因为上面的int a是全局的，没有失效；</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了这些，for循环和while循环也一样  </p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><p><del>我嘞个豆啊，想着水一篇的，怎么写了这么多</del><br>记录时间：2024.10.7 21.45</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mz_C++基本程序HelloWord</title>
    <link href="/2024/10/07/mz_CPP%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8FHelloWord/"/>
    <url>/2024/10/07/mz_CPP%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8FHelloWord/</url>
    
    <content type="html"><![CDATA[<h3 id="C-的基础程序-HelloWord"><a href="#C-的基础程序-HelloWord" class="headerlink" title="C++的基础程序 HelloWord"></a>C++的基础程序 HelloWord</h3><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs">#include &lt; iostream &gt;  using namespace std;  int main()  &#123;    cout &lt;&lt; &quot;Hello Word!!!&quot;;  &#125;</code></pre><p>程序输出：</p><blockquote><p>Hello Word!!!</p></blockquote><ul><li><p><strong>#include &lt; iostream &gt;</strong><br>这是一个调用iostream库的代码，调用过来才能使用里面的东西<br><code>#include</code><br>调用库的意思，后面像上面的一样用&lt;&gt;括起来<br><code> &lt;iostream&gt;</code><br>代表的调用的是iostream库  </p></li><li><p><strong>using namespace std;</strong><br>这的意思是将命名空间std引用到程序里<br><code>using</code><br>这就是引用后面的命名空间的代码<br><code>namespace</code><br>这是为当前这个域都定义名字，像这里写的就是为当前域命名为std  </p></li><li><p><strong>int main()</strong><br>创建main主函数里面的花括号用来证明里面的代码是main函数的  </p></li><li><p><strong>cout &lt;&lt; “Hello Word!!!”;</strong><br>cout用来打印文字一类的，将Hello Word!!!打印到屏幕上。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mz_念の博客</title>
    <link href="/2024/10/07/mz_%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/10/07/mz_%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="欢迎来到我的博客"><a href="#欢迎来到我的博客" class="headerlink" title="欢迎来到我的博客"></a>欢迎来到我的博客</h2><p>这个博客以后将会和我的室友共同使用，我和他的文章会用头标签分开，我（mz），他（DT）</p><h4 id="我为什么要做这个博客？"><a href="#我为什么要做这个博客？" class="headerlink" title="我为什么要做这个博客？"></a>我为什么要做这个博客？</h4><p>这个的原因挺简单的，我想通过博客的方式记录每天的学习内容</p><p>也没啥能说的，就看我后面更新的文章吧<br><del>时不时的还会发会颠</del><br>咳咳咳</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
